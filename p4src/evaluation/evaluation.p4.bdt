@BDT_file(metadata_name="meta", max_tree_depth="4", fields_bits="16")

#include <core.p4>
#include <v1model.p4>

#include "includes/evaluation_consts.p4"
#include "includes/evaluation_headers.p4"
#include "includes/evaluation_parser.p4"
#include "includes/evaluation_checksums.p4"
#include "evaluation_controls.p4"

/*
    Switch ingress pipeline
*/
control SwitchIngress(
    inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t standard_metadata)
{

    register<bit<16>>(8) queue_length_reg;
    register<bit<1>>(8) neighbor_switch_indicator;
    register<bit<3>>(1) max_free_space_queue_id; 

    Routing() routing;

    action set_physical_deflect_port_from_id(bit<9> physical_port) {
        meta.deflect_port = physical_port;
    }

    table set_physical_deflect_port_from_id_table {
        key = {
            meta.deflect_port: exact;
        }
        actions = {
            set_physical_deflect_port_from_id;
        }
        size = 8;
    }

    action set_switch_id(bit<8> switch_id) {
        meta.switch_id = switch_id;
    }

    table set_switch_id_table {
        actions = {
            set_switch_id;
        }
        size = 1;
    }

    @BDT_check_action(field="meta.switch_id")
    @BDT_check_action(field="meta.queue_lenght_4")
    @BDT_check_action(field="meta.queue_lenght_5")
    @BDT_check_action(field="meta.queue_lenght_6")
    @BDT_check_action(field="meta.queue_lenght_7")

    @BDT_leaf_action(action_name="deflect"){
        standard_metadata.egress_spec = meta.deflect_port;
    }

    @BDT_leaf_action(action_name="forward"){
    }

    @BDT_tables(table_base_name="BDT_table")

    apply {
        if (hdr.bee.isValid()) {
            neighbor_switch_indicator.read(meta.neighbor_switch_indicator, (bit<32>)hdr.bee.port_id);
            if(meta.neighbor_switch_indicator == 1){
                queue_length_reg.write((bit<32>)hdr.bee.port_id, (bit<16>)hdr.bee.queue_length);
                bit<3> max_free_space_queue_id_tmp;
                max_free_space_queue_id.read(max_free_space_queue_id_tmp, (bit<32>)hdr.bee.port_id);
                bit<16> max_free_space_queue;
                queue_length_reg.read(max_free_space_queue, (bit<32>)max_free_space_queue_id_tmp);
                bit<16> free_space = QUEUE_CAPACITY - hdr.bee.queue_length;
                if (free_space > max_free_space_queue) {
                    max_free_space_queue_id.write((bit<32>)0, (bit<3>)hdr.bee.port_id);
                }
            }
        } else if (hdr.ipv4.isValid() &&
                  (hdr.ipv4.protocol == IP_PROTOCOLS_TCP ||
                   hdr.ipv4.protocol == IP_PROTOCOLS_UDP)) {
        
            routing.apply(hdr, meta, standard_metadata);
            
            max_free_space_queue_id.read(meta.deflect_port_id, (bit<32>)0);
            set_physical_deflect_port_from_id_table.apply();

            //TODO: metto solo quelle che mi interessano
            //queue_length_reg.read(meta.queue_lenght_0, (bit<32>)0);
            //queue_length_reg.read(meta.queue_lenght_1, (bit<32>)1);
            //queue_length_reg.read(meta.queue_lenght_2, (bit<32>)2);
            //queue_length_reg.read(meta.queue_lenght_3, (bit<32>)3);
            queue_length_reg.read(meta.queue_lenght_4, (bit<32>)4);
            queue_length_reg.read(meta.queue_lenght_5, (bit<32>)5);
            queue_length_reg.read(meta.queue_lenght_6, (bit<32>)6);
            queue_length_reg.read(meta.queue_lenght_7, (bit<32>)7);

            set_switch_id_table.apply();
            
            @BDT_apply()
        }
    }

}



control SwitchEgress(
    inout header_t            hdr,
    inout metadata_t          meta,
    inout standard_metadata_t standard_metadata)
{
    register<bit<16>>(8) queue_length_reg;

    action get_eg_port_id_action(bit<3> index) {
        meta.port_id = index;
    }
    
    table get_eg_port_id_table {
        key = {
            standard_metadata.egress_port: exact;
        }
        actions = {
            get_eg_port_id_action;
        }
        size = TABLE_SIZE;
    }

    apply {
        if (hdr.bee.isValid()) {
            queue_length_reg.read(hdr.bee.queue_length, (bit<32>)hdr.bee.port_id);
            recirculate_preserving_field_list(0);
        } else {
            if (hdr.ipv4.isValid() && (hdr.ipv4.protocol == IP_PROTOCOLS_TCP || hdr.ipv4.protocol == IP_PROTOCOLS_UDP)) {
                get_eg_port_id_table.apply();
                queue_length_reg.write((bit<32>)meta.port_id, (bit<16>)(standard_metadata.deq_qdepth)); //Dopo che il pacchetto lascia la coda, pensaci!!
            }
        }
    }
}


//switch architecture
V1Switch(SwitchParser(),
         SwitchVerifyChecksum(),
         SwitchIngress(),
         SwitchEgress(),
         SwitchComputeChecksum(),
         SwitchDeparser()
) main;
